

# 前端工程化

### 一.webpack

### 1.作用

- 本质：以 JS 为中心的模块打包工具 (loader,plugin处理各类型资源) 
- 模块打包，代码转译，资源优化
- 减少浏览器http请求次数

### 2.基础配置

mode，entry,output ,module,plugin

### 3.项目打包构建

**流程**：开发阶段 → 代码检查 → 打包编译 → 压缩优化 → 生成产物 → 部署上线

**构建策略**：单一打包/代码分割/懒加载/差异化构建（现阶段不深入）

### 4.前端缓存

概念：浏览器提供的各种存储和缓存机制

1. http缓存（用于静态资源）强缓存，直接从缓存读取，不发送请求

2. 浏览器缓存（数据持久化）：cookie（浏览器本地小型文本文件），LocalStorage（浏览器本地存储功能）

3. 前端数据库（IndexedDB）

4. 内存缓存（两种框架的计算缓存）

   ```javascript
   useMemo/useCallback(react)
   computd/keep-alive(vue)
   ```

5. 方案替代：PWA = 一整套让网页变得像原生APP的技术方案，离线访问只是其中一个功能

   seesion（服务器端用户会话数据）这不是浏览器缓存，但是概念有重叠	















，函数编程，贴合，为了让它生效。

压缩与混淆，还很重要



啥叫微前端

单次HTTP请求 = DNS查询 + TCP连接 + 等待响应 + 下载文件



node都是用common.js来安装指定包的吗

### webpack 5 的改进（当前主流）：

- 更好的缓存机制（二次打包超快）

- 更小的打包体积

- 更好的 Tree Shaking（自动删除没用的代码）

- 模块联邦（可以让多个项目共享代码）

- ### webpack 4 的重大改进（最重要）：

  - **零配置**：不写配置文件也能用
  - 自动区分开发/生产模式
  - 打包速度大幅提升

bundle.js (2MB)



promise.ten与prompt.then

bundle.js要重点理解

文件加上哈希值，避免因修改内容，而由于缓存机制，代码没有更新，

这个可以作为一个场景题

hash深入复习一下，并练一下代码下







### rollup

rollup除了打包中间代码小，有什么优势

vite底层用到rollup打包

esbuild是个啥

 vite开箱即用，即便不写配置也可以直接使用，那针对于各种类型的项目本身，是什么情况下需要配置vite呢



![image-20251222225724125](C:\Users\朱德成\AppData\Roaming\Typora\typora-user-images\image-20251222225724125.png)

### 2.babel

### 编译原理

三个步骤：

1.解析（词法分析，语法分析）：代码转化成token流,token流转化为AST

2.转换 :遍历AST并对其进行修改，Vistitor Pattern, Plugin 

3.生成:修改的AST转化成代码字符串

关键概念：

1.token流：代码字符串按照语法规则，切分成一个个有意义的词汇

2.AST:源代码的树结构，提供结构代码，便于分析和修改



## 二.性能优化

### 1.babel角度

**第一是构建速度优化，提升开发效率。**

首先会开启持久化缓存，配置cache设置为filesystem类型，这样二次构建速度能提升5到10倍。然后对于一些耗时的loader，比如babel-loader，可以使用thread-loader开启多线程编译。另外要合理配置include和exclude，缩小文件处理范围，避免去转译node_modules里的代码。

**第二是打包体积优化，提升用户体验。**

首先要做代码压缩，生产环境使用TerserPlugin压缩JavaScript，CssMinimizerPlugin压缩CSS。然后利用Tree Shaking删除未使用的代码，这个需要使用ES6模块语法才能生效。接下来是代码分割，通过splitChunks配置把公共依赖和第三方库单独打包，这样能充分利用浏览器缓存。对于一些非首屏的模块，可以使用动态import实现懒加载，减少首屏加载时间。

**除此之外，还可以使用webpack-bundle-analyzer插件分析打包结果，找出体积过大的模块进行针对性优化。对于一些大型库，比如lodash，可以按需引入，或者用CDN的方式通过externals配置排除打包。**

**总结来说，webpack优化的核心思路就是：构建更快、包更小、加载更快。但优化要基于实际项目情况，用分析工具找到瓶颈，针对性解决，避免过度优化。"**



### 2.**首屏优化**

**的核心策略包括代码分割（路由懒加载、splitChunks）、资源优化（图片懒加载和压缩、字体优化）、打包优化（Tree Shaking、代码压缩）、缓存优化（文件名哈希）、CSS优化（提取和压缩）、网络优化（CDN、HTTP/2、预加载）、SSR/SSG和性能监控，其中代码分割和图片优化是影响最大、必须要做的优化！** 💪



## 三.！Nodejs的使用

### 1.相关定义

**node.js**：javascript服务器端运行环境，让js能够访问文件系统，网络操作等系统资源。



### 2.模块化编程

**定义：**将一个大的模块，拆分成小的几个模块，这些模块相互独立，并且通过导入导出进行使用	





### 3.esm

ESM 是 ECMAScript 的官方模块标准，使用 `import/export` 语法。它有别于 Node.js 早期使用的 CommonJS 模块系统（`require/module.exports`）



common js（模块化编程方案）->服务端

define定义模块，require导出模块



官方，浏览器服务器通用，ECMAScript Module方案 esm

```
module.export
import
```



eval啥意思

生产模式，开发模式区别，搞透彻一点

根据环境不同，webpack做不同的事

前端部署到服务器上，和webpack有什么关系，是直接源代码么，还是webpack打包后的代码，还是需要编译？？

根据环境变量的不同，配置webpack 

webpack与node的关系

编程式配置

![image-20251221002304049](C:\Users\朱德成\AppData\Roaming\Typora\typora-user-images\image-20251221002304049.png)

没有命名规范吗，这中间不一样啊



Rust开发工具链的流程



vite的相关使用

http与https在前端中的使用



dify ai

html5编程



待做：

1.在vscode里添加一些常见的mcp服务器

3.图片的base64，小图片转化成base64,大图片转化？？，增加http请求？？

4.ts相关面试题，ts整理

5.我的react记录，先从那个项目开始，然后选择一个最经典的react项目，跟着举步维艰得敲代码，总之

6.React要拿下

webpack用的是common.js导入模块还是啥？不是很明确







## 7.快速开始 - koroFileHeader的使用

### 1. 安装插件

在 VS Code 中搜索并安装：`koroFileHeader`

vue是单个页面，创建时会顶掉

！8.前端的缓存问题处理



异步操作，会不会抓取异常？

1. 但会引入 **polyfill（补丁代码）**



http深入

**现代浏览器（支持 HTTP/2）：**

- 可以并行加载多个小文件
- 不需要打包成大文件

**老浏览器（只支持 HTTP/1.1）：**

- 并行连接数有限
- 需要把文件打包减少请求次数

easyui是不是前端ui框架，我怎么记得在java后端项目里实现的

前端html插入debugger，可以进行断点调试



解决react和ts的相关问题

windows对象是不是浏览器对象，给个教程

不同静态资源载入的差异有啥不同
